import {CustomButton} from './examples/CustomButton';
import {CustomCard} from './examples/CustomCard';
import {CustomIcon} from './examples/CustomIcon';
import {CustomText} from './examples/CustomText';
import {StyledButton} from './examples/StyledButton';

<Meta title="Styling/ How to Customize Styles" />

# How To Customize Styles

There are multiple ways to customize styles for our components within Canvas Kit. What approach you
choose depends on your use case. Ranging from some simple overrides to fully custom solutions, here
are the following options.

- [Styles](#styles)
- [Stencils](#stencils)

## Styles

### Use `createStyles` With `cs` If

Use `createStyles` in tandem with `cs` prop when you're overriding static styles and making small
modifications to an existing Canvas Kit component like padding, color and flex properties. Take our
`Text` component as an example.

```tsx
import {createStyles} from '@Workday/canvas-kit-styling';
import {system} from '@Workday/canvas-tokens-web';
import {Text} from '@Workday/canvas-kit-react/text';

const uppercaseTextStyles = createStyles({
  textTransform: 'uppercase',
  margin: system.space.x4
})
//...
<Text cs={uppercaseTextStyles}>My uppercased text</Text>;
```

> **Note:** `createStyles` handles wrapping our token variables in `var(--${tokenName})`

## Stencils

### Use Stencils If

Use `createStencil` when you're creating reusable component styles that can either be dynamic,
modified by props, or extended. `createStencil` allows you to compose your styles in a predictable
way.

```tsx
export const buttonStencil = createStencil({
  vars: {
    backgroundColor: '',
    textColor: '',
  },
  base: ({backgroundColor, textColor}) => ({
    backgroundColor: cssVar(backgroundColor, base.berrySmoothie400),
    borderRadius: system.shape.x1,
    color: cssVar(textColor, base.frenchVanilla100),
    border: `1px solid transparent`,
    alignSelf: 'center',
    cursor: 'pointer',
    '&:hover': {
      backgroundColor: cssVar(backgroundColor, base.berrySmoothie500),
    },
    '&:active': {
      backgroundColor: cssVar(backgroundColor, base.berrySmoothie600),
    },
  }),
  modifiers: {
    size: {
      small: {
        padding: system.sapce.x2,
      },
      medium: {
        padding: system.space.x4,
      },
    },
  },
});
// Reusable Button Component
export const Button = createComponent('button')({
  Component({size = 'small', children, ...elemProps}: ButtonProps, ref, Element) {
    return (
      <Element ref={ref} {...handleCsProp(elemProps, buttonStencil({size: size}))}>
        {children}
      </Element>
    );
  },
});
```

> **Note:** We're using `handleCsProp` which handles the merging of `className`, `style` and `cs`
> prop correctly.

### Overriding Stencil Variables

Often times, styles can be dynamic resulting in component Stencils exposing CSS variables that can
be used to override styles. Our Buttons are a great example of how to do this. In the example below,
we're using the variables exposed by `buttonStencil` which is used to build our `PrimaryButton`,
`SecondaryButton`, `TertiaryButton`'s and changing the variables to completely overrite styles for
different visual states. Overriding styles in this way abstracts out the need to know the underlying
dom structure of our Buttons while giving you access to style effectively and predictably.

<ExampleCodeBlock code={CustomButton} />

Here's another example of using stencil variables to customize styles with our icons:

<ExampleCodeBlock code={CustomIcon} />

### Stencils extentions

<ExampleCodeBlock code={CustomCard} />
