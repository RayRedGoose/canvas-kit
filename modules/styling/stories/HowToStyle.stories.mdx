import {CustomButton} from './examples/CustomButton';
import {CustomIcon} from './examples/CustomIcon';
import {StyledButton} from './examples/StyledButton';

<Meta title="Styling/ How to Customize Styles" />

# How To Customize Styles

There are multiple ways to customize styles for our components within Canvas Kit. The approach you
choose will depend on your use case. Ranging from some simple overrides to fully custom solutions, here
are the following options:

- [Styles](#styles)
- [Stencils](#stencils)

## Styles

### Use `createStyles` With `cs` If

Use `createStyles` in tandem with `cs` prop when you're overriding static styles and making small
modifications to an existing Canvas Kit component like padding, color and flex properties. Take our
`Text` component as an example.

```tsx
import {createStyles} from '@Workday/canvas-kit-styling';
import {system} from '@Workday/canvas-tokens-web';
import {Text} from '@Workday/canvas-kit-react/text';

const uppercaseTextStyles = createStyles({
  textTransform: 'uppercase',
  margin: system.space.x4
})
//...
<Text cs={uppercaseTextStyles}>My uppercased text</Text>;
```

> **Note:** `createStyles` handles wrapping our token variables in `var(--${tokenName})`

## Stencils

### Use Stencils If

Stencils help you organize the styling of reusable components into base styles, modifiers, and
variables. The organization makes it more natural to produce static and clean CSS with optional
extraction into CSS files.

```tsx
export const buttonStencil = createStencil({
  vars: {
    backgroundColor: '',
    textColor: '',
  },
  base: ({backgroundColor, textColor}) => ({
    backgroundColor: cssVar(backgroundColor, base.berrySmoothie400),
    borderRadius: system.shape.x1,
    color: cssVar(textColor, base.frenchVanilla100),
    border: `1px solid transparent`,
    alignSelf: 'center',
    cursor: 'pointer',
    '&:hover': {
      backgroundColor: cssVar(backgroundColor, base.berrySmoothie500),
    },
    '&:active': {
      backgroundColor: cssVar(backgroundColor, base.berrySmoothie600),
    },
  }),
  modifiers: {
    size: {
      small: {
        padding: system.sapce.x2,
      },
      medium: {
        padding: system.space.x4,
      },
    },
  },
});
// Reusable Button Component
export const Button = createComponent('button')({
  Component({size = 'small', children, ...elemProps}: ButtonProps, ref, Element) {
    return (
      <Element ref={ref} {...handleCsProp(elemProps, buttonStencil({size: size}))}>
        {children}
      </Element>
    );
  },
});
```

> **Note:** We're using `handleCsProp` which handles the merging of `className`, `style` and `cs`
> prop correctly.

## Stencils For Reusable Components

Stencils allow you compose component styles that need to handle modifiers (variants) while also
exposing variables that can be modified.

<ExampleCodeBlock code={CustomButton} />

Here's another example of using stencil variables to customize styles with our icons:

<ExampleCodeBlock code={CustomIcon} />
